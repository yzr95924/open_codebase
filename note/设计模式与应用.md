---
typora-copy-images-to: ../paper_figure
---
设计模式与应用
----------------------------------------
[ToC]

## 设计原则与设计模式基本概念
- 所有的设计原则和设计模式都是为了更容易的实现**高内聚低耦合**
  - 正交四原则
    - 最小化覆盖
    - 分离变化
    - 缩小依赖范围
    - 向稳定方向依赖
  - 在面向对象发展过程中，提出更具体的**SOLID原则**
    - **单一职责 （SRP）**
    - **向扩展开放/向修改封闭（OCP）**
    - **子类要能替换父类（LSP）**
    - **接口隔离/最小化接口依赖（ISP）**
    - **依赖倒置/只依赖接口（DIP）**
- 正交四原则和SOLID原则的具体含义和关系
  - 正交四原则
    - 最小化原则
      - 重复意味着耦合

    - 分离变化
      - **识别变化方向并对变化预留扩展接口**

    - 缩小依赖范围
      - 依赖接口，不要依赖实现

    - 向稳定方向依赖
      - 站在需求的角度去定义API
      - 要站在客户的角度去定义API，而不是站在实现者的角度

  - SOLID原则
    - **单一职责**
      - 消除重复，分离变化

    - **开闭原则**
      - 对扩展开放，对修改关闭
      - 识别变化方向，用接口封装变化

    - **里氏替换原则**
      - 依赖稳定接口

    - **接口分离原则**
      - 最小知识原则

    - **依赖倒置原则**
      - 双方都依赖抽象，不依赖于具体实现
      - 依赖稳定接口

- 23种设计模式分类&简述
  - **创建型**
    - Factory Method（工厂方法）
    - Abstract Factory（抽象工厂）

  - **结构型**
    - Adapter Class/Object（适配器）
    - Facade（外观）

  - **行为型**
    - Chain of Responsibility（责任链）
    - Observer（观察者）


## 常用设计模式

- 创建型模式 - **工厂方法**
  - 问题
    - 创建对象的具体逻辑和使用对象的逻辑耦合在一起
      - 创建对象的逻辑会不断修改 --> **违背了开闭原则**
  - 优化方法
    - 通过简单工厂类抽取书籍对象的创建。**使用和创建分离**
      - **封闭对象的创建逻辑**
    - 抽象工厂方法
      - 进一步实现不同分类的工厂
  - 缺点
    - **使得系统中类的个数不断增加**
    - **增加了系统的复杂度**
  - 使用场景
    - 当**子类型可能会用很多**，以后**需要不断增加**不同的子类型实现时
    - 当一个系统**尚在框架设计阶段，还不知道将来需要实例化哪些具体类**
    - 系统在**设计之初**不需要具体对象的概念
      - 或者说**没有具体对象的概念**
    - 在工厂方法模式中，客户端**不需要知道具体产品类的类名**
      - 只需要知道所对应的工厂
- 创建型模式 - **抽象工厂方法**
  - 屏蔽工厂的差异
  - 缺点
    - 工厂族扩展非常困难 --> **产品族的概念**
  - 使用场景
    - 创建产品家族，**相关产品集合在一起使用**的时候
    - 想要提供一个**产品类库**，并**只想显示其接口而不是实现时**
    - 通过**组合的方式使用工厂时**
    - 系统中**有多于一个的产品族**
    - 属于**同一个产品族的产品将在一起使用**
    - 产品**等级结构稳定**，设计完成后，**不会**向系统中**增加新的产品等级结构或者删除已有的产品等级结构**
- 结构型模式
  - 如何**将类或者对象结合在一起形成更大的结构**
  - **类结构型模式**
    - 关心类的组合，由多个类可以组成一个更大的系统
      - 一般只存在继承关系和实现关系
  - **对象结构型模式**
    - 关系类与对象的组合，通过关联关系使得**在一个类中定义另一个类的实例对象，然后通过该对象调用其方法**
- 结构型模式 - **适配器模式**
  - 定义接口类，对外提供统一的接口
    - 无需改动现有业务类
    - 可复用现有业务类
    - 可灵活扩展
  - **将某个类的接口转换成客户端期望的另一个接口**
    - 消除由于接口不匹配所造成的**兼容性问题**
    - 类的适配器模式
      - 将一个**类**转换成**满足另一个新接口的类**时
    - 对象的适配器模式
      - 将一个**对象**转换成**满足另一个新接口的对象**时
- 结构型模式 - **外观模式**
  - 问题
    - 对外暴露过多的接口，增加外部集成复杂度，暴露过多细节，增大系统安全风险
  - 增加外观类，封装接口
    - **为多个子部件提供统一接口，简化客户端调用**
    - 解除各子部件跟客户端的耦合，提升系统安全性
  - 优点
    - **降低系统间及系统与外部的耦合度**，提升安全性
    - 简化了系统的接口，更易于使用系统
  - 缺点
    - 对统一接口的使用可能会引入较多约束，降低了使用系统的灵活性
    - 不易于修改，子系统的变动可能会引起外观层甚至客户端的改动
      - 违背**开闭原则**
- 结构型模式 - 适配器模式与外观模式对比
  - 都是**对现有接口进行转换以满足需求**
  - 适配器模式是**将现有接口转变成需要的接口**
  - 外观模式是为了各子系统的提供一个**统一接口**，简化**系统对外接口**
- 行为型模式 - 观察者模式
  - 定义目标和观察者
    - 通过客户类把目标和观察者组织起来
  - 问题
    - 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用
    - 通知**发布的时间会随观察者的增多而增长，影响程序的效率**
  - 定义与实现原理
    - 多个对象间存在一对多的依赖关系
      - 当一个对象的状态发生改变时 --> **依赖它的对象都得到通知并自动更新**
    - 结构
      - 抽象主题
      - 具体主题
      - 抽象观察者
      - 具体观察者
  - 总结
    - 优点
      - 降低了目标与观察者之间的耦合关系，两者之间时**抽象耦合关系**
      - 目标与观察者之间**建立了一套触发机制**
    - 使用场景
      - 对象间存在**一对多的关系**，一个对象的状态发生改变**会影响其他对象**
      - 当一个抽象模型有两个方面
        - 一个方面依赖于另一方面 --> 可将这两者封装在独立的对象中以使它们可以**各自独立低改变和复用**
- 行为型模式 - 责任链模式的实现
  - 通过客户端把处理者组成责任链
  - 复杂的系统可能会有较长的责任链
  - 定义与实现原理
    - **为了避免请求发送者与多个请求处理者耦合在一起**
      - 将所有请求的处理者通过前一对象记住其下一个对象的引用而形成一条**链**
      - 当有请求发生时，**可将请求沿着这条链传递，直到有对象处理它为止**
    - 结构
      - 抽象处理者
      - 具体处理者
      - 客户类
        - 负责创建**处理链**
  - 总结
    - 优点
      - 降低了对象之间的耦合度
      - 增加了系统的可扩展性
        - 按需增加新的请求处理类 --> 满足开闭原则
      - 责任分担
    - 使用场景
      - 有多个对象处理一个请求，**哪个对象处理该请求由运行时刻自动确定**
      - 可**动态指定**一组对象处理请求
      - 在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求
- 行为型模式 - 回顾与思考
  - 用于多个类或对象之间，完成单个对象都无法单独完成的任务
  - 责任链和观察者模式都**降低了对象之间的耦合关系**，增强了系统的可扩展性

## 设计模式的学习方法

- 经典书籍的学习
  - Head First - 设计模式
  - 大话设计模式
- 基于实际业务边练边学
- 针对性问题上网找答案
- 总结
  - 设计模式、SOLID原则、正交四原则、都是为了更容易的实现**高内聚低耦合**
  - 23种设计模式
    - 创建型（5种）
    - 结构型（7种）
    - 行为型（11种）
  - 工厂方法
    - 屏蔽了某种对象的创建过程，**1：1**的  
  - 抽象工厂方法
    - 实现对一个产品族对象的创建，**1：N**的
  - 适配器模式
    - 转化某个类现有的接口，消除**兼容性问题**
  - 外观模式
    - 为一个复杂的系统对外提供一个统一的接口，将复杂屏蔽在内部，让客户端更**易于使用**
  - 观察者模式
    - 实现依赖倒置
    - 让**数据持有者**不再去关注**数据消费者**
  - 责任链模式
    - 将新增的处理行为以链条的方式串联起来
    - 为使用者提供了**新增行为**和排布行为间的**先后顺序**的**扩展机制**
      - 传递抽象的数据